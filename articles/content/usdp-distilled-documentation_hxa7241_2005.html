<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head profile="http://dublincore.org/documents/dcq-html/">
   <title>USDP Distilled eXtreme Documentation - HXA7241 - 2005</title>

   <link rel="schema.DC"       href="http://purl.org/dc/elements/1.1/" />
   <meta name="DC.title"       content="USDP Distilled eXtreme Documentation - HXA7241 - 2005" />
   <meta name="DC.subject"     content="Software development, Documentation, Unified Software Development Process, USDP, eXtreme Programming, XP" />
   <meta name="DC.description" content="A description of a simple software technical documentation format and process." />
   <meta name="DC.type"        content="technical article" />
   <meta name="DC.type"        content="Text" />
   <link rel="DC.relation"     href="http://www.hxa.name/" />
   <meta name="DC.creator"     content="Harrison Ainsworth / HXA7241" />
   <meta name="DC.publisher"   content="Harrison Ainsworth / HXA7241" />
   <meta name="DC.rights"      content="Creative Commons BY-SA 3.0 License." />
   <meta name="DC.date"        content="2005-10-08" />
   <meta name="DC.date"        content="2006-09-04" />
   <meta name="DC.format"      content="text/html" />
   <meta name="DC.format"      content="css1" />
   <meta name="DC.language"    content="en" />
   <link rel="DC.identifier"   href="http://www.hxa.name/articles/content/usdp-distilled-documentation_hxa7241_2005.html" />

   <meta name="keywords"       content="Software development, Documentation, Unified Software Development Process, USDP, eXtreme Programming, XP" />
   <meta name="description"    content="A description of a simple software technical documentation format and process." />
   <meta name="document"       content="hxa7241article5" />
   <meta name="license"        content="Creative Commons by-sa 3.0" />

   <link rel="stylesheet" type="text/css" href="hxa7241-article.css" />

   <script id="hxa7241-js" type="application/x-javascript" src="../../style/hxa7241.js"></script>
</head>


<body>
<div class="edge" id="header"><div><a href="http://www.hxa.name/articles/">HXA articles</a></div></div>

<div class="paper">


<div id="heading">
   <h1>USDP-Distilled eXtreme Documentation</h1>
</div>


<div id="colophon">
<h4>Harrison Ainsworth</h4>

   <p id="contact"><a href="http://www.hxa.name/">http://www.hxa.name/</a>
   <br />artifex <i>(&alpha;&tau;)</i> hxa7241 <i>(d&omicron;&tau;)</i> org</p>

   <p id="timestamp">2006-09-04</p>
</div>


<div id="preface">
   <div id="summary">
      <h2>Summary</h2>
      <p>This is a description of a simple software technical documentation format and process. It is derived from the Unified Software Development Process, simplified towards eXtreme Programming compatibility, and arranged for realisation in a plain text file. (1600 words)</p>
   </div>

   <dl id="metadata" class="plainlist">
      <dt>subject</dt>
      <dd>Software development, Documentation, Unified Software Development Process, <acronym title="Unified Software Development Process">USDP</acronym>, eXtreme Programming, <acronym title="eXtreme Programming">XP</acronym></dd>

      <dt>uri</dt>
      <dd><a href="http://www.hxa.name/articles/content/usdp-distilled-documentation_hxa7241_2005.html">http://www.hxa.name/articles/content/usdp-distilled-documentation_hxa7241_2005.html</a></dd>

      <dt>license</dt>
      <dd><a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons BY-SA 3.0 License</a>.</dd>
   </dl>
</div>


<div id="contents">
   <h2>Contents</h2>
   <ul>
      <li><a href="#proposition">Proposition</a></li>
      <li><a href="#overview">Overview</a></li>
      <li><a href="#usdpstructures">USDP structures</a></li>
      <!--<li><a href="#xpconcepts">XP concepts</a></li>-->
      <li><a href="#inception">Inception</a></li>
      <li><a href="#elaboration">Elaboration</a></li>
      <li><a href="#arrangement">Arrangement</a></li>
      <li><a href="#example">Example</a></li>
      <li><a href="#references">References</a></li>
   </ul>
</div>


<div id="text">

<div class="section" id="proposition">
<h3>Proposition</h3>

   <p>This article presents a documentation format and process made from a simple specialisation of the Unified Software Development Process. The specialisation is tailored toward eXtreme Programming compatibility. The presentation follows the purpose of the book &lsquo;<acronym title="Unified Modelling Language">UML</acronym> Distilled&rsquo; &mdash; a description of essentials for everyday use.</p>

   <p>This documentation form was developed with small projects. Many (perhaps most) software projects are small, and their technical documentation is often an afterthought. Creating a simple pattern for a high-level view at this scale would be useful. And large projects, if well-designed, would have a significant modularisation that might fit this too.</p>

   <p>The USDP was chosen as a source because it is one of the best thought-out elucidations of process, architecture, and development. And it is not <i><span xml:lang="la" lang="la">per se</span></i> proprietary. XP has an eminent practicality, and the two combine well because they share core principles of user-story motivation, architectural centrality, and iterative development.</p>
</div>


<div class="section" id="overview">
<h3>Overview</h3>

   <p>The purpose of a distilled documentation is to communicate the high-level system structure in a simple, recognizable and repeatable pattern. The process fixes the making of it to a development project.</p>

   <p>The format consists of a single document in plain text. Its content conforms to a minimal &lsquo;syntax&rsquo; that has an automated conversion to <acronym title="HyperText Markup Language">HTML</acronym>. UML diagrams are supplemental, if present.</p>

   <p>The structure is built mostly of USDP model descriptions. Each is headed by a colloquial summary, and detailed by hierarchical lists.</p>

   <p>The process divides production into two periods: Inception and Elaboration. The first develops an initial, partial, draft to express preparational thinking. The second refines the whole, encompassing the iterations to a stable architectural description.</p>

   <p>The core notion of USDP documentation is to carry an abstracted &lsquo;architecture description&rsquo; through phases. This is composed of views of each of the models, based on architecturally significant use cases &mdash; those having the most important functionality and risk.</p>

   <p>In XP, the concept of the &lsquo;metaphor&rsquo; parallels this, but, though lacking formality, it emphasises the illustrative summary. That must be the guiding intention for this documentation format.</p>

</div>


<div class="section" id="usdpstructures">
<h3>USDP structures</h3>

   <p>Here is a brief summary of USDP structures used.</p>

   <h4>Material</h4>

   <p>The &lsquo;material&rsquo; division of the USDP is the model. The models are views of the system, and are a mixture of aspects and levels. They are, with their emphases:</p>

   <ul>
      <li>Requirements <i>(aspect)</i></li>
      <li>Analysis <i>(level)</i></li>
      <li>Design <i>(level)</i></li>
      <li>Deployment <i>(aspect)</i></li>
      <li>Implementation <i>(level)</i></li>
      <li>Test <i>(aspect)</i></li>
   </ul>

   <p>Adapted from USDP section 1.5.1:</p>

   <h5>Requirements</h5>
   <p>A system's external behaviour is described by a set of use cases. Each use case is a sequence of actions that provide the user with a result of value. With some supplementary requirements, this constitutes the requirements model.</p>

   <h5>Analysis</h5>
   <p>This is an initial allocation of the behaviour of the system to a set of objects. The perspective is from the outside, leaving implementational considerations aside.</p>

   <h5>Design</h5>
   <p>This defines the static structure of the system as subsystems, classes, and interfaces; and realizes the use-cases as collaborations among those elements.</p>

   <h5>Deployment</h5>
   <p>How the executables etc. are packaged and arranged.</p>

   <h5>Implementation</h5>
   <p>The code. Includes components (representing source code) and the mapping of the classes to components.</p>

   <h5>Test</h5>
   <p>An outline of the overall integration tests, and important unit tests. (Not usually included in the USDP architecture description.)</p>

   <h4>Procedural</h4>

   <p>The secondary &lsquo;procedural&rsquo; division of the USDP is the phase. A phase is a grouping of iterations covering a major stage in a project's maturity. There are four:</p>

   <ul>
      <li>Inception &mdash; <i>forming a seed</i></li>
      <li>Elaboration &mdash; <i>developing a skeleton</i></li>
      <li>Construction &mdash; <i>most coding</i></li>
      <li>Transition &mdash; <i>preparing for release</i></li>
   </ul>

   <h5>Inception</h5>
   <p>This phase develops the vision of, and business case for, the product. It forms answers to the following questions, from USDP section 1.5.2 and 13.0:</p>

   <ul>
      <li>What is the system primarily going to do for each of its major users?</li>
      <li>What could an architecture for that system look like?</li>
      <li>What is the plan and what will it cost to develop the product?</li>
   </ul>

   <p>Ultimately it is about gaining a fair amount of confidence that the system is both possible and desirable to develop.</p>

   <!--<p>Stresses requirements
   identify 50% and describe 10% of use cases
   prioritise use cases</p>-->

   <h5>Elaboration</h5>
   <p>This phase pushes development further by filling in more details of the architecture. The aim being to enable a plan of activities and estimate of resources needed.</p>

   <p>In summary, it is about clarifying how and when all parts of the system can be built.</p>

   <!--<p>identify 80% and describe 60% of use cases</p>-->

   <p>Since only the high-level description is of concern, only Inception and Elaboration are relevant. Thereafter the architecture would be expected to change minimally.</p>

   <p>The USDP's divisions of work and role are left aside.</p>

</div>


<!--<div class="section" id="xpconcepts">
<h3>XP concepts</h3>

   <h4>Metaphor</h4>
   
   <p>The means of communicating the overall structure of the system is the metaphor. It is a simple shared illustration of how the whole system works. No form is mandated, but a sense of cohesion, and that it be understandable by business and technical sides.</p>
   
   <h4>Stories</h4>

   <p>one thing the customer wants the system to do.
   testable.
   1-5 weeks dev time.</p>

   <h4>Iterations</h4>

   group of stories built and added to system.
   unit of development.
   1-5 weeks.</p>
   
   planning?
      ch 15

   process
      ch 21

   <p>Other XP matters are left aside.</p>

</div>-->


<div class="section" id="inception">
<h3>Inception</h3>

   <p>During the initial period of a project the first draft of the document is written.</p>

   <p>Almost any development project includes preparational thinking and note-making. That can be channeled into the start of this more disciplined form. This will produce a proto architecture description.</p>

   <p>First, the Proposition. This is the most important part &mdash; the seed of the whole, answering the most basic questions of the project: what is it, why do it, and can it be done.</p>

   <p>Second, the Models. These capture the incipient structure of the software. At this early stage the activity is merely to identify and prioritise most expected elements of the system. Of foremost importance are the use cases, since they drive the next stage of development.</p>

   <p>Third, the Plan. This points the way forward to Elaboration, and previews its work. Also, a provisional, but reasonable, estimate can be made of time and resources needed for the whole project.</p>

   <p>Recalling the <i>leitmotiv</i> of XP metaphor, all these parts of the document are aimed at illustrative summary.</p>

   <p>When is Inception finished? The answer is not a matter of software structure. It is as soon as the project appears possible and desirable, and a cursory survey has been made of the land ahead. For a more XP approach, when there are a set of use cases for the first iteration, that is a clear indication.</p>

   <p>The document probably should now be less than 12K or 1500 words.</p>

   <h4>the document</h4>

   <ul>
      <li>
         <b>Proposition</b>
         <br /><i>paragraphs, lists, quotes</i>
         <ul>
            <li>why</li>
            <li>how &mdash; tech/algorithms basis</li>
            <li>aims</li>
         </ul>
      </li>
      <li>
         <b>Models</b>
         <ul>
            <li>
               <b>Requirements</b>
               <br /><i>a section for each use case</i>
               <ul>
                  <li>
                     use cases
                     <br /><i>an ordered list of the sequence</i>
                  </li>
                  <li>features
                     <br /><i>an unordered list of supplementary requirements</i>
                  </li>
               </ul>
            </li>
            <li>
               <b>Analysis</b>
               <ul>
                  <li>
                     patterns
                     <br /><i>paragraphs noting any important ones used</i>
                  </li>
                  <li>
                     packages
                     <br /><i>a list allocating their responsibilities</i>
                  </li>
               </ul>
            </li>
            <li>
               <b>Design</b>
               <ul>
                  <li>
                     components/libraries
                     <br /><i>a list of any reused</i>
                  </li>
               </ul>
            </li>
            <li>
               <b>Deployment</b>
               <ul>
                  <li>
                     delivery packages
                     <br /><i>a list of the executables and configurations</i>
                  </li>
                  <li>
                     plugins
                     <br /><i>a list of customisation points</i>
                  </li>
               </ul>
            </li>
            <li>
               <b>Implementation</b>
               <ul>
                  <li>
                     compilers, tools, platform specificities
                     <br /><i>a list</i>
                  </li>
               </ul>
            </li>
         </ul>
      </li>
      <li>
         <b>Plan</b>
         <ul>
            <li>
               estimate
               <br /><i>time, from size and rate</i>
            </li>
            <li>
               elaboration order
               <br /><i>an ordered list of forthcoming work</i>
            </li>
         </ul>
      </li>
   </ul>

</div>


<div class="section" id="elaboration">
<h3>Elaboration</h3>

   <p>In this phase the documentation grows into its full form. The work is to inherit and refine from Inception, and expand it with further material.</p>

   <p>With the Models, what is needed now is to describe and define the most important elements of the system. Although the detail will be closer to implementation, it needs to be kept above the flux of code.</p>

   <p>When is elaboration finished? A more USDP approach would make this a second iteration of <i>preliminary</i> work. And it would continue until no visible risks obstruct any paths of construction. Or, a more XP way would be a gradual solidifying in <i>parallel</i> with construction, continuing until the architecture is stable (The first use cases having been chosen to lead across the whole system early).</p>

   <p>The product is a full, light-weight, &lsquo;architecture description&rsquo;. The document probably should now be less than 32K or 4000 words.</p>

   <h4>the document</h4>

   <ul>
      <li>
         <b>Proposition</b> <i>(inherit)</i>
      </li>
      <li>
         <b>Models</b>
         <ul>
            <li>
               <b>Requirements</b>
               <ul>
                  <li>Use cases <i>(inherit)</i></li>
                  <li>features <i>(inherit)</i></li>
               </ul>
            </li>
            <li>
               <b>Analysis</b>
               <ul>
                  <li>patterns <i>(inherit)</i></li>
                  <li>
                     packages and dependencies
                     <br /><i>lists of additional or refined dependencies for all</i>
                  </li>
                  <li>
                     classes in packages
                     <br /><i>lists of subsumed classes</i>
                  </li>
               </ul>
            </li>
            <li>
               <b>Design</b>
               <ul>
                  <li>components/libraries <i>(inherit)</i></li>
                  <li>
                     class interfaces
                     <br /><i>a list of classes with indications of their interfaces</i>
                  </li>
                  <li>
                     sequences
                     <br /><i>ordered lists sketching important procedural structures</i>
                  </li>
               </ul>
            </li>
            <li>
               <b>Deployment</b>
               <ul>
                  <li>delivery packages <i>(inherit)</i></li>
                  <li>plugins <i>(inherit)</i></li>
               </ul>
            </li>
            <li>
               <b>Implementation</b>
               <ul>
                  <li>compilers, tools, platform specificities <i>(inherit)</i></li>
                  <!--<li>prototypes</li>-->
               </ul>
            </li>
            <li>
               <b>Test</b>
               <br /><i>a list of overall functional tests</i>
            </li>
         </ul>
      </li>
      <li>
         <b>Technical Notes</b>
         <br /><i>unstructured/inchoate background details of algorithms</i>
      </li>
      <li>
         <b>Plan</b>
         <ul>
            <li>estimate <i>(inherit)</i></li>
            <li>elaboration order <i>(inherit)</i></li>
            <li>
               construction order
               <br /><i>an ordered list of forthcoming work</i>
            </li>
            <li>
               next version prospectus
               <br /><i>a list of possible improvements and features</i>
            </li>
         </ul>
      </li>
   </ul>

</div>


<div class="section" id="arrangement">
<h3>Arrangement</h3>

   <p>The document is a plain text file, arranged in Markdown &lsquo;syntax&rsquo;. This is a set of simple conventions for expressing common textual microformats, derived from common email writing styles. Tools can convert this to HTML, although it is perfectly readable merely as text. Here is a brief introduction:</p>

   <ul>
      <li>
         <b>headings</b>
         <br />underlined with lines of &lsquo;=&rsquo; or &lsquo;-&rsquo;, or bracketed with &lsquo;###&rsquo;s
      </li>
      <li>
         <b>paragraphs</b>
         <br />a block of text surrounded by blank lines
      </li>
      <li>
         <b>lists</b>
         <br />elements begin with &lsquo;*&rsquo;, or &lsquo;1.&rsquo; etc. for ordered
      </li>
      <li>
         <b>emphasis</b>
         <br />words bracketed with &lsquo;_&rsquo; or &lsquo;*&rsquo;, doubled for bold
      </li>
      <li>
         <b>links</b>
         <br />[an example](http://example.com/ "Title")
      </li>
      <li>
         <b>blockquotes</b>
         <br />begin lines with &lsquo;> &rsquo;
      </li>
      <li>
         <b>code</b>
         <br />indent lines with a tab or 4 spaces
      </li>
      <li>
         <b>auto escaping</b>
         <br />&amp; and &lt; are translated into &amp;amp; and &amp;lt;
      </li>
   </ul>

   <p>The following example section shows some usages. A complete guide to Markdown is available at <a href="http://daringfireball.net/projects/markdown/">http://daringfireball.net/projects/markdown/</a></p>

   <p>The following <acronym title="Cascading Style Sheets">CSS</acronym> could be added to the HTML:</p>

<pre><code>/* HXA7241 USDP-Distilled documentation stylesheet */

body
{
   color:             black;
   background-color:  white;
   font-family:       sans-serif;
   font-size:         14px;
   text-align:        left;
   text-indent:       0em;
   width:             50em;
   border:            0 none;
   margin-top:        7em;
   margin-bottom:     7em;
   margin-left:       auto;
   margin-right:      auto;
}
h1
{
   font-size:         3em;
   font-weight:       normal;
   margin-top:        0em;
   margin-bottom:     1em;
}
h2
{
   font-size:         1.75em;
   font-weight:       normal;
   margin-top:        3em;
   margin-bottom:     0.5em;
}
h3
{
   font-size:         1.2em;
   font-weight:       bold;
   margin-top:        1em;
   margin-bottom:     0em;
}
h4
{
   font-size:         1em;
   font-weight:       bold;
   margin:            0.5em 0 0.5em 0;
}
h5
{
   font-size:         1em;
   font-weight:       bold;
   margin:            0 1.5em 0 0;
   float:             left;
}
h6
{
   font-size:         1em;
   font-weight:       bold;
   margin:            0 1.5em 0 0;
   float:             left;
}
p
{
   text-indent:       0em;
   margin-top:        0.5em;
   margin-bottom:     0.5em;
}
pre
{
   font-family:       monospace;
   font-size:         1em;
   text-align:        left;
   white-space:       pre;
   margin-top:        1em;
   margin-bottom:     1em;
}
ol, ul
{
   margin:            0.5em 2em 0.5em 3em;
   padding:           0;
}
dl
{
   margin:            0.5em 2em 0.5em 2em;
}
table
{
   font-size:         1em;
   margin-top:        1em;
}
img
{
   border:            1px solid black;
   margin:            16px 0 16px 0;
}
code
{
   font-family:       monospace;
   font-size:         1em;
}
li, dt, dd
{
   margin-top:        0.25em;
   margin-bottom:     0.25em;
}
dt
{
   font-weight:       bold;
}
a:link, a:visited
{
   color:             black;
   background-color:  white;
   text-decoration:   none;
}
a:hover
{
   color:             black;
   background-color:  white;
   text-decoration:   underline;
}
a:active
{
   color:             black;
   background-color:  rgb(208,208,208);
   text-decoration:   underline;
}
</code></pre>

</div>


<div class="section" id="example">
<h3>Example</h3>

   <p>This is a small, less than 5000 line / 2 month, project for a component to be used in high-quality 3D graphics rendering. (<a href="http://www.hxa.name/tonemapper/">Project here.</a>)</p>

   <p>The document is 8K and 1000 words. Work on the two phases, including producing the document, took 11 hours.</p>

<pre><tt>P3 Tonemapper Architecture Description
======================================


### Harrison Ainsworth ###

&lt;http://www.hxa.name/tonemapper/&gt;  
artifex at computer dot org

2005-10-06




Contents
--------

* Proposition
* Requirements
* Analysis
* Design
* Deployment
* Implementation
* Test
* Technical Notes
* Plan
* References




Proposition
-----------

Develop a premium tone-mapper component available as source code and executable.

Implement Ward-Larson's 1997 paper:

&gt; 'A Visibility Matching Tone Reproduction Operator for High Dynamic Range
&gt; Scenes'  
&gt; Ward Larson, Rushmeier, Piatko;  
&gt; IEEE TVCG 1997.
&gt;
&gt; &lt;http://radsite.lbl.gov/radiance/papers/lbnl39882/tonemap.pdf&gt;

Tone mapping is a necessary stage of rendering, but it is usually an
after-thought. A good component could fill a gap in the open-source rendering
world. It can be well-separated and made reusable without architectural
ramifications. It is quite small and simple, so do-able in a month or two.

Aims:

* well-separated and reusable
* input common/usual/standard images
* output common/usual/standard images
* C++ code
* Windows executable
* Linux executable
* be the best open-source tone-mapper




Requirements
------------

Requirements are simple: there is only one use case, and a few supplementary
features. The use case follows basic command-line tool form: read a file,
process it, output a file. But this is augmented with an options file containing
switches and metadata.


### Use Case ###

(actor - user, or renderer)
1. input command file
2. input HDR image (XYZ, RGB (maybe with conversion))
3. (maybe read output error file, then repeat from first step)
4. receive RGB int (8,16bit) image file (PNG, simple)


### Use Case Features ###

* human or ideal viewer
* manual calibration of for input image
* tone, bloom, color, acuity
* color conversion
* output: RGB int
* output: PNG, simple




Analysis
--------

The primary division is to separate the core processing from everything else
more general. `format` and `image` may later move out to general external
packages.


### Packages ###

* tonemap  
  -- application specific classes
* format  
  -- image file formats classes for OpenEXR, PNG and simple
* image  
  -- image classes with color space awareness

reuse:
* hxa7241_graphics  
  -- general graphics code
* hxa7241_general  
  -- very generally useful cross-project code


### Package Dependencies ###

* image
   * ImageRgbFloat
   * ImageRgbInt
   * ColorTransform
* format
   * image
   * libpng
   * OpenEXR
* tonemap
   * PerceptualMap
      * image
      * Foveal
         * ImageRgbFloat
      * Veil
         * ImageRgbFloat
         * Foveal
      * AcuityFilter
         * ImageRgbFloat
         * ColorTransform
      * ColorAdjustment
         * ImageRgbFloat
         * ColorTransform
      * ToneAdjustment
         * ImageRgbFloat
         * ImageRgbInt
         * Foveal
* all
   * general
   * graphics
      * general

#### reused ####
* general
   * Array&lt;&gt;
   * Clamps
   * FpToInt
   * Interval
   * Sheet&lt;&gt;
* graphics
   * ColorConstants
   * Vector3f
   * Matrix3f




Design
------

The tonemap package classes fall into three groups: some specialised images,
some image operators, and one overall workflow-context.


### Components/Libraries Reused ###

image file format support:
* OpenEXR
* libpng


### Class Interfaces ###

* PerceptualMap
   * construct with options, or defaults
   * set options
   * map image to image

* Foveal : ImageRgbFloat
   * construct from original image

* Veil : ImageRgbFloat
   * construct from foveal image
   * mix into ImageRgbFloat

* ToneAdjustment
   * construct with Foveal and output luminance range
   * map ImageRgbFloat to ImageRgbInt

* AcuityFilter
   * map ImageRgbFloat to ImageRgbFloat

* ColorAdjustment
   * map ImageRgbFloat to ImageRgbFloat

* ImageRgbFloat : Sheet&lt;Vector3f&gt;
   * access color conversion

* ImageRgbInt : Sheet&lt;Vector3w&gt;
   * read pixels as word array

* ColorTransform
   * construct with options
   * set options
   * convert a triple, forward or back

* format
   * read RGB EXR into RGB float triples
   * write RGB int triples into PNG, ...


### Sequences ###

1. read command file
2. read original image file
3. make PerceptualMap
4. map original image to final image
   1. make foveal image
   2. apply human viewer limitations
      1. make veil image
      2. mix veil into foveal image
      3. mix veil into original image
      4. adjust original image for color sensitivity
      5. filter original image for acuity
   3. make ToneAdjustment
      1. make histogram
      2. adjust histogram
      3. make cumulative function from histogram
   4. map original image with ToneAdjustment
5. write final image file




Deployment
----------

A simple, basic form eases portability, and the usage allows it, so: a
command-line program is best. This could also be packaged as a dynamic-link
library. Maybe the image format readers could be externalised as plugins.

* command-line program
   * in: (commands, HDR image (standard format))
   * out: (RGB (standard format), log)
* dynamic-link library
   * alternative version of command-line program
* image format reader and writer plugins
   * could find dynamic-link libraries, and give each a chance to read




Implementation
--------------

Just straightforward, portable C++.

* C++, with exceptions, minimal template use, no RTTI
* MSToolkit or MinGW compilers
* nothing platform specific




Test
----

Not decided yet...  
Something precise and numerical is desirable.  
There are some source and result images, using the same algorithm, at:
&lt;http://www.anyhere.com/gward/hdrenc/pages/originals.html&gt;




Technical Notes
---------------

1. input original image
   * pixels: RGB float (maybe with color space)

2. make image of foveal values
   * pixels: RGB float
   * (box/cheap) filter to 1 degree/pixel size
   * pixelcount = 2 * tan( viewangle / 2 ) / 0.01745

3. human viewer
   * make image of veil, from foveal image
      * pixels: RGB float
      * same resolution as foveal image
      * (color, not just luminance)
      * (slowest part - big convolution ...)

   * mix veil into foveal

   * mix veil into original
      * (with a bilinear interpolation)

   * adjust original image for color sensitivity
      * needs conversion to XYZ (to get foveal luminance)

   * filter original image for acuity
      * needs conversion to XYZ (to get foveal luminance)
      * variable blur - mipmap?

4. make histogram, from foveal image
   * needs conversion to XYZ
   * elements: log10 of luminances
   * 100 bins
   * min = min val, clamped to min of 10^-4
   * max = max val
   * log10lum -&gt; log10lum
   * (linearly interpolatable)

5. adjust histogram
   * clamp counts, using iterative convergence
      * linear ceiling - ideal viewer
      * varying ceiling - human viewer

6. map original image with histogram

7. output final image
   * pixels: RGB int


command file:
* input image
   * optional color space
* is human viewer
   * is glare
   * is color sense
   * is acuity
* display
   * black luminance
   * white luminance


(luminance is cd/m^2, remember?)




Plan
----

### estimate ###

* total size: 2300 lines (discluding reuse)
* rate: 3 minutes per line
* time: 115 hours ~ 28 days ~ 6 weeks ~ 1.3 months


### elaboration order ###

1. image types
2. color conversion
3. tonemap
   1. PerceptualMap
   2. Foveal
   3. Veil
   4. ToneAdjustment
   5. AcuityFilter
   6. ColorAdjustment
4. formatting


### construction order ###

1.  basic skeleton app
2.  image types
3.  color conversion
4.  PerceptualMap
5.  Foveal
6.  Veil
7.  ToneAdjustment
8.  AcuityFilter
9.  ColorAdjustment
10. basic in/out formatters
11. package app
12. other formatters


### version 2 prospectus ###

* accelerate
   * C++ first
   * CPU streaming instruction support
   * assess graphics card use

* flare feature  
  -- the more localised eye scattering effects -- Cornell paper in Siggraph 1995

* white/color shift feature  
  -- simulating the human perception that white looks white even when
  illumination is colored.  
  -- research needed




References
----------

* 'A Visibility Matching Tone Reproduction Operator for High Dynamic Range
  Scenes'  
  Ward Larson, Rushmeier, Piatko;  
  IEEE TVCG 1997.  
  &lt;http://radsite.lbl.gov/radiance/papers/lbnl39882/tonemap.pdf&gt;

* 'A Model of Visual Adaptation for Realistic Image Synthesis'  
  Ferwerda, Pattanaik, Shirley, Greenberg;  
  Siggraph 1996.  
  &lt;http://www.graphics.cornell.edu/pubs/1996/FPSG96.pdf&gt;

* 'Physically-based Glare Effects for Digital Images'  
  Spencer, Shirley, Zimmerman, Greenberg;  
  Siggraph 1995.  
  &lt;http://www.graphics.cornell.edu/pubs/1995/SSZG95.pdf&gt;

* 'Illumination And Color In Computer Generated Imagery'  
  Hall;  
  Springer 1989.  
  0-387-96774-5.

* OpenEXR high dynamic range image format  
  &lt;http://www.openexr.com/&gt;

* PNG image format  
  &lt;http://www.libpng.org/&gt;

* sRGB color space  
  &lt;http://www.w3.org/Graphics/Color/sRGB&gt;
</tt></pre>

</div>

</div>


<div id="references">
<h2>References</h2>

   <ul>
      <li>&lsquo;The Unified Software Development Process&rsquo;
         Booch, Jacobson, Rumbaugh;
         Addison Wesley, 1999.
      </li>
      <li>
         &lsquo;Extreme Programming Explained&rsquo;
         Beck;
         Addison Wesley, 1999.
      </li>
      <li>
         &lsquo;UML Distilled&rsquo; 3rd ed.
         Fowler;
         Addison Wesley, 2003.
      </li>
      <li>
         &lsquo;Markdown&rsquo;
         Gruber;
         <a href="http://daringfireball.net/projects/markdown/">http://daringfireball.net/projects/markdown/</a>
      </li>
      <li>
         Markdown in Ruby,
         Granger;
         <a href="http://www.deveiate.org/projects/BlueCloth">http://www.deveiate.org/projects/BlueCloth</a>
      </li>
   </ul>

</div>


</div>

<div class="edge" id="footer"><div><a href="http://www.hxa.name/articles/">http://www.hxa.name/articles/</a></div></div>

<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-596081-1";
urchinTracker();
</script>

</body>

</html>
