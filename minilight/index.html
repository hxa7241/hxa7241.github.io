<!DOCTYPE html>
<html lang="en-GB" id="hxa7241-minilight" class="hxa7241-software">

<head>
   <title>&lt; H X A 7 2 4 1 &gt; : minilight</title>
   <meta charset="UTF-8" />

   <link rel="stylesheet" type="text/css" href="../style/hxa7241-main-2016.css" />
</head>

<body>

   <header id="top-head">
      <h1><a href="http://www.hxa.name/"><img src="../style/hxa7241-logo-h.svg" alt="HXA7241" /></a></h1>
      <div id="sub-head"><a href="../#software">software</a></div>
      <div id="subsub-head">various software projects</div>
   </header>

   <main>
      <article class="artefact">

<header class="artefact-head">
<pre><code>"artefact-metadata-hxa7241-www": {
  "title": "Minilight",
  "author": "Harrison Ainsworth",
  "date": "2013-05-04",
  "id": "urn:uuid:ED2B5718-E341-4829-AACB-5A71FC101075",
  "type": "article",
  "subtype": "text/html",
  "wordcount": 2218,
  "hashsecure": "sha256:d00bd0d860c02ccc<wbr/>fec61ace720f4766<wbr/>82e6f8ec8cbe3a0c<wbr/>31ab84008e1d54bc",
  "location": "http://www.hxa.name/minilight/"
}</code></pre>
</header>

<!-- hash next element -->
<section class="artefact-body">
   <h2>Minilight</h2>
   <p class="artefact-summary">a minimal global illumination renderer</p>

   <table class="artefact-menu">
      <tr>
         <td>
            <ul>
               <li><a href="#desc">Description</a></li>
               <li><a href="#images">Images</a></li>
               <li><a href="#comparison">Comparison</a></li>
               <li><a href="#algorithm">Algorithm</a></li>
               <li><a href="#pseudocode">Pseudocode</a></li>
               <li><a href="#downloads">Downloads</a></li>
               <li><a href="#contribution">Contribution</a></li>
            </ul>
         </td>
      </tr>
   </table>

   <section id="desc">
      <h3>Description</h3>

      <p id="desc-p0">MiniLight is a <b>minimal</b> global illumination renderer. It is primarily an exercise in simplicity. But that makes it a good base and benchmark (in some sense) for development and experimentation. And it just might be the <i>neatest</i> renderer around (on average, about 650 lines). There are translations into several programming languages.</p>

      <p id="desc-p1"><i>Someone asked me how to develop a renderer in three months. It seemed not nearly enough time. But then I began to think how small such a program could be, whilst still being a complete physically based simulation with a clear, well-formed design. (A somewhat different aim from the &lsquo;Minimal Ray Tracer Programming Contest&rsquo; of 1987.) I couldn't resist an attempt.</i></p>

      <p id="desc-p2">It is a <b>command-line</b> application. It reads a simple text model file and writes a <a href="http://netpbm.sourceforge.net/doc/ppm.html">PPM</a> image file. Supported platforms include <b>Mac</b> üçè, <b>Linux</b> üêß, and <b>Windows</b>.</p>

      <p id="desc-p3">The rendering features are:</p>
      <ul>
         <li>Monte-carlo path-tracing transport</li>
         <li>Emitter sampling</li>
         <li>Progressive refinement</li>
         <li>RGB light</li>
         <li>Diffuse materials</li>
         <li>Triangle modelling primitives</li>
         <li>Octree spatial index</li>
         <li>Pin-hole &lsquo;lens&rsquo;</li>
         <li>Ward linear tone-mapping</li>
      </ul>

      <p id="desc-p4">Full <b>source code</b> is provided under the <a href="http://creativecommons.org/publicdomain/zero/1.0/">CC0 license</a>.</p>
   </section>


   <section id="images">
      <h3>Images</h3>

      <p id="images-p0">A <a href="http://www.graphics.cornell.edu/online/box/"><b>Cornell Box</b></a> (of course) throughout the day:</p>

      <table class="panel">
         <tr>
            <td>
               <a href="cornellbox-m.ml1.jpg">
                  <img src="cornellbox-m-small.ml1.jpg" width="64" height="64" alt="Cornell Box at morning" title="Matutinal: skylight only." class="thumbnail" /></a>
               <div class="thumbcaption">Cornell Box, at morning <small>(24 KiB)</small></div>
            </td>
            <td>
               <a href="cornellbox-n.ml1.jpg">
                  <img src="cornellbox-n-small.ml1.jpg" width="64" height="64" alt="Cornell Box at noon" title="Meridiemal: strong sun and skylight. Note the form of the bright reflections around the lower parts of the boxes." class="thumbnail" /></a>
               <div class="thumbcaption">Cornell Box, at noon <small>(23 KiB)</small></div>
            </td>
            <td>
               <a href="cornellbox-e.ml1.jpg">
                  <img src="cornellbox-e-small.ml1.jpg" width="64" height="64" alt="Cornell Box at evening" title="Vespertinal: soft red sun and yellow sky, and artificial light. Note the very slightly soft edges of the shadows at the back -- due to the sun's size and distance." class="thumbnail" /></a>
               <div class="thumbcaption">Cornell Box, at evening <small>(26 KiB)</small></div>
            </td>
            <td>
               <a href="cornellbox.ml1.jpg">
                  <img src="cornellbox-small.ml1.jpg" width="64" height="64" alt="Cornell Box at night" title="Nocturnal: artificial light only." class="thumbnail" /></a>
               <div class="thumbcaption">Cornell Box, at night <small>(23 KiB)</small></div>
            </td>
         </tr>
      </table>

      <p id="images-p1">The models are physically based too. For example, at noon: The sky has a colour temperature of 10000K and a luminance of 1 x 10<sup>4</sup> cd/m<sup>2</sup>. The sun has a colour temperature of 5400K and a luminance of 1 x 10<sup>9</sup> cd/m<sup>2</sup>, a diameter of 1.392 x 10<sup>9</sup> m, and distance of 149.6 x 10<sup>9</sup> m. (<i>It is just a square though.</i>)</p>

      <p id="images-p2">Some of the <a href="http://www.cs.utah.edu/~bes/papers/scenes/"><b>Smits test scenes</b></a>:</p>

      <table class="panel">
         <tr>
            <td>
               <a href="smits-tests.ml1.jpg">
                  <img src="smits-tests-small.ml1.jpg" width="96" height="32" alt="Smits tests" class="thumbnail" /></a>
               <div class="thumbcaption">Smits tests <small>(32 KiB)</small></div>
            </td>
         </tr>
      </table>

      <p id="images-p3">A room, at noon-ish, and night <i>(made in HDR and tonemapped with <a href="../tonemapper/">p3tonemapper</a>)</i>:</p>

      <table class="panel">
         <tr>
            <td>
               <a href="roomfront-n.ml1.jpg">
                  <img src="roomfront-n_small.ml1.jpg" width="103" height="64" alt="Front room at noon" title="Meridiemal: strong sun and skylight." class="thumbnail" /></a>
               <div class="thumbcaption">Front room, at noon <small>(97 KiB)</small></div>
            </td>
            <td>
               <a href="roomfront.ml1.jpg">
                  <img src="roomfront_small.ml1.jpg" width="103" height="64" alt="Cornell Box at noon" title="Nocturnal: artificial light only." class="thumbnail" /></a>
               <div class="thumbcaption">Front room, at night <small>(47 KiB)</small></div>
            </td>
         </tr>
      </table>

      <p id="images-p4">All these renders are 1000 paths per pixel. The standard Cornell Box, at 500 x 500 pixels, should take about 15 minutes on a 2007 machine.</p>

      <p id="images-p5">(Models/scenes are just in a simple individual text format, but <i>if</i> they were in JSON a suggested <a href="http://json-schema.org/"><b>JSON-schema</b></a> of the <a href="model-json-schema.json">model/scene format is here</a>.)</p>
   </section>


   <section id="comparison">
      <h3>Comparison</h3>

      <p id="comparison-p0">There are now eight translations:</p>
      <table class="panel">
         <thead>
            <tr>
               <th>language<br/><small>and version</small></th><th>size<br/><small>lines of code</small></th><th>size<br/><small>relative to C</small></th><th>speed<br/><small>paths per sec</small></th><th>speed<br/><small>relative to C</small></th>
            </tr>
         </thead>
         <tbody>
            <tr>
               <td><a href="http://csapp.cs.cmu.edu/3e/docs/chistory.html">üåä</a> <b>C</b> <a href="http://www.open-std.org/JTC1/SC22/WG14/www/standards">ISO-90</a> <small>(LLVM-GCC-4.2)</small></td><td><span title="memory management (and exception handling) is the main addition over C++">1249</span></td><td>1</td><td>92445</td><td>1</td>
            </tr>
            <tr>
               <td><a href="http://www.stroustrup.com/C++.html">üåä</a> <b>C++</b> <a href="http://isocpp.org/">ISO-98</a> <small>(LLVM-G++-4.2)</small></td><td><span title="even without separate class-headers it would still be over 600...">957</span></td><td>0.79</td><td>62580</td><td>1 / 1.5</td>
            </tr>
            <tr>
               <td><a href="http://www.schemers.org/">üçê</a> <b>Scheme</b> R5RS <small><a href="http://racket-lang.org/">(Racket 5.3)</a></small></td><td><span>677</span></td><td>0.56</td><td>1263.0</td><td>1 / 73</td>
            </tr>
            <tr>
               <td><a href="http://www.lua.org/">üåô</a> <b>Lua</b> <a href="http://luajit.org/">LuaJIT</a> 2.0.1</td><td>557</td><td>0.46</td><td>6889.0</td><td><span title="LuaJIT has very unpredictable speed">1 / 13</span></td>
            </tr>
            <tr>
               <td><a href="http://www.lua.org/">üåô</a> <b>Lua</b> 5.2.2</td><td>557</td><td>0.46</td><td>1320.1</td><td><span title="the new bit-operations do not really help the speed">1 / 70</span></td>
            </tr>
            <tr>
               <td><a href="http://www.ruby-lang.org/">üíé</a> <b>Ruby</b> 1.8.7</td><td>523</td><td>0.43</td><td>185.46</td><td>1 / 500</td>
            </tr>
            <tr>
               <td><a href="http://www.python.org/">üêç</a> <span title="Translation by Juraj Sukop"><b>Python</b></span> <a href="http://shed-skin.blogspot.com/">Shed</a><a href="https://github.com/shedskin/shedskin">Skin</a> 0.1.1</td><td><span title="very little adjustment needed by shedskin">516</span></td><td>0.42</td><td>24985</td><td>1 / 3.7</td>
            </tr>
            <tr>
               <td><a href="http://www.python.org/">üêç</a> <span title="Translation by Juraj Sukop"><b>Python</b></span> <a href="http://pypy.org/">PyPy</a> 2 beta 1</td><td>510</td><td>0.42</td><td>5658.0</td><td>1 / 16</td>
            </tr>
            <tr>
               <td><a href="http://www.python.org/">üêç</a> <span title="Translation by Juraj Sukop"><b>Python</b> 2.6.1</span></td><td><span title="significant-blank-space gives it the edge over Ruby...">510</span></td><td>0.42</td><td>403.79</td><td>1 / 230</td>
            </tr>
            <tr>
               <td><a href="http://ocaml.org/">üê´</a> <b>OCaml</b> 4.00.1</td><td><span title="type-inference and expression-orientation make this very concise...">473</span></td><td>0.39</td><td>40282</td><td>1 / 2.3</td>
            </tr>
            <tr>
               <td><a href="http://www.scala-lang.org/">üêö</a> <a href="minilight-scala-code.html"><b>Scala</b> 2.10.0</a></td><td><span>444</span></td><td>0.36</td><td>20082</td><td>1 / 4.6</td>
            </tr>
         </tbody>
      </table>

      <p id="comparison-p1">Line counts disclude comments and blanks and lines with only single braces/parentheses.</p>

      <p id="comparison-p2">Speed measurements were done on a Core2-Duo Mac, using the <a href="roomfront.ml.txt"><code>roomfront</code></a> (non-sun) model. They are just rough indications.</p>

      <p id="comparison-p3">&lsquo;Paths&rsquo; actually also send a &lsquo;shadow ray&rsquo; at each node &ndash; so twice the paths-per-second would give general basic ray-traces/intersections-per-second.</p>

      <p id="comparison-p4">C was faster than C++ probably mostly because LLVM's link-time optimisation worked for C, but <span title="run-time error: 'error for object 0x4d555458: Non-aligned pointer being freed'">not for C++</span>.</p>

      <p id="comparison-p5">Scala, Lua and Ruby are twice as slow without some manual optimization (Python too, probably). This is mostly inlining some vector operations (but also a little loop unrolling, and flattening the image pixel array).</p>

      <p id="comparison-p6"><a href="minilight-flex.html">Try an older Flex version here . . .</a></p>
   </section>


   <section id="algorithm">
      <h3>Algorithm</h3>

      <h4 id="algorithm.pathtracing">path tracing</h4>
      <p id="algorithm.pathtracing-p0">The simplest method of global illumination is pure <b>monte-carlo path tracing</b>. For each pixel, a ray is sent into the scene. When it hits something it notes its color and emission. It then bounces off and continues. Eventually all the noted info is sent back, step by step. Each step scales the light by certain factors until a final value is returned to the pixel. Repeat the whole process many times with some randomness added and average all the results. An image slowly emerges.</p>

      <p id="algorithm.pathtracing-p1">This strategy is essentially a blind search for light emitters. Unless a ray hits an emitter it will return only blackness. For outdoor scenes most rays will bounce into the sky, and find brightness. But for indoors the emitters are small and many many rays are needed to find them. It is too slow.</p>

      <h4 id="algorithm.emittersampling">emitter sampling</h4>
      <p id="algorithm.emittersampling-p0">This can be alleviated with <b>emitter sampling</b>. The location of all emitters is known from the model, and this can be used. Each step sends an extra ray to an emitter. But now there are two rays gathering the incoming light they must not duplicate any. To ensure this, &lsquo;local&rsquo; emission at each bounce is no longer included.</p>

      <h4 id="algorithm.montecarlo">monte carlo</h4>
      <p id="algorithm.montecarlo-p0">Each interaction along the main path is handled mostly by monte-carlo. The bounce direction is chosen by <b>importance sampling</b>: proportionally more likely in directions the surface allows more reflection through. For ideal diffuse that is lots near perpendicular, little near grazing. The overall reflectivity is controlled by <b>russian-roulette</b>: proportionally more likely to bounce the more reflective the surface is. This allows a non-arbitrary end for the recursion. The colour is just scaling, because there is no advantage in monte-carlo there.</p>

      <p id="algorithm.montecarlo-p1">Both uses of monte-carlo sample more where the surface interaction transfers more light. This is a fairly good approach.</p>

      <p id="algorithm.montecarlo-p2">Why? A simple analysis is that apparent noisiness is the product of detail/richness and intensity: greater detail means adjacent pixels more likely see different values, greater intensity probably means more contrast. The latter is easiest to address, because interaction's effect on intensity is simple. The treatment&mdash;sampling more&mdash;reduces noise by averaging-out the effect of the randomness.</p>

      <p id="algorithm.montecarlo-p3">Over many iterations this puts more computation into resolving more visibly noisy regions, rather than wasting it on regions that won't noticeably improve. That computes an image of particular quality more quickly. But there are still shortcomings . . .</p>

      <h4 id="algorithm.renderingequation">rendering equation</h4>
      <p id="algorithm.renderingequation-p0">Here is the specific rendering equation for this algorithm:</p>
      <img src="rendering-equation.png" width="575" height="143" alt="L_o(x, \vec w) = \int_\Omega L_i(x, \vec w') (\vec w' \cdot \vec n) \frac{\rho}{\pi}\, d\vec w' \ \ + \ \ \sum_E\int_A L_e(z, \vec w'') \Gamma_A V(x,z) (\vec w'' \cdot \vec n) \frac{\rho}{\pi}\, d a" />
      <p id="algorithm.renderingequation-p1">Meaning: The radiance outward at a position and direction equals the sum of two terms (the first representing the main path, the second the emitter sampling). The first term integrates over the surrounding hemisphere of directions the inward radiance scaled by its projection and the reflectivity function. The second term sums over all emitters, for each integrating over the area the emission scaled by the solid angle, the visibility, the projection, and the reflectivity function.</p>

      <!--
      (generatable by www.wikipedia.org)

      <math>L_o(x, \vec w) = \int_\Omega L_i(x, \vec w') (\vec w' \cdot \vec n) \frac{\rho}{\pi}\, d\vec w' \ \ + \ \ \sum_E\int_A L_e(z, \vec w'') \Gamma_A V(x,z) (\vec w'' \cdot \vec n) \frac{\rho}{\pi}\, d a</math>

      <math>L_o(x, \vec w) = \frac{\rho}{\pi} \int_\Omega L_i(x, \vec w') (\vec w' \cdot \vec n)\, d\vec w' \ \ + \ \ \sum_E \left [ \frac{\rho}{\pi} \Gamma_A \int_A L_e(z, \vec w'') V(x,z) (\vec w'' \cdot \vec n)\, d a \right ] </math>
      -->

      <!--<pre>L[posR,dirOut] =
      intHemisphere( L[posI,-dirIn] * vis(posR,posI) *
         cos(dirIn,normR) * (rfl[posR] / pi) ) +
      sumEmitters(
         intArea( Le[posE,-dirIn] * sldang(A) * vis(posR,posE) *
            cos(dirIn,normR) * (rfl[posR] / pi) ) )</pre>-->

      <h4 id="algorithm.unbiased">unbiased?</h4>
      <p id="algorithm.unbiased-p0">Monte-carlo path-tracing is described as &lsquo;<b>unbiased</b>&rsquo;. The term is now sometimes used in the manner of a marketing tag. Its real meaning is too abstract for that purpose. It denotes a lack of consistent error&mdash;the only error is in the effects of the randomness. Such niceties are appropriate for mathematics but for engineering we must live by practicalities. <b>All implementations</b> are <span title="consider: finite rendering time, floating point, modelling, imaging...">biased and incorrect in various ways</span>. The task is to arrange them acceptably.</p>

      <h4 id="algorithm.ultimately">ultimately</h4>
      <p id="algorithm.ultimately-p0">The value of this method is its simplicity, while having full generality. It allows the implementation to be almost proven correct by inspection. <i>(Correct meaning &lsquo;following the rules for a particular standard approximation&rsquo;.)</i> The images produced can be authoritative references for other renderers.</p>
      <p id="algorithm.ultimately-p1">The core idea has also proven remarkably durable and adaptable since Whitted's paper of 1980. One could reasonably call it the key engineering concept for rendering, and it looks to remain so.</p>

   </section>


   <section id="pseudocode">
      <h3>Pseudocode</h3>

      <p id="pseudocode-p0">Here is the algorithmic structure in high-level pseudocode/PDL (produced by editing the code comments into a reduced form).</p>

      <p id="pseudocode-p1">Whereas the actual source-code is broken into modules and procedures, this represents the sequence in a single coherent view. Thought of like geographic maps, the first is roughly 38:1 scale, the second 10:1.</p>

      <!--<p>(Each line links to (near) the corresponding part of the Scala translation page. [TODO: need to add ids to Scala page])</p>-->

      <h4 id="highlevel">high-level &ndash; 38:1 Scale</h4>

      <p id="pseudocode.highlevel-p0">17 lines &ndash; roughly 1 for every 38 of actual code.</p>

<pre><code>- render, by progressive refinement
  - render a frame, to the image
    - sample each image pixel
      - make sample ray direction
      - get radiance returning in sample direction
        - intersect ray with scene
        - if intersection hit
          - get local emission (only for first-hit)
          - calculate emitter sample
          - calculate recursive reflection
          - sum local emission, emitter sample, and recursive reflection
        - else no hit
          - use default/background scene emission
      - add radiance to image
  - save image
    - divide pixel values by frame count
    - apply tonemapping factor</code></pre>

      <h4 id="mediumlevel">medium-level &ndash; 10:1 Scale</h4>

      <p id="pseudocode.mediumlevel-p0">66 lines &ndash; roughly 1 for every 10 lines of actual code.</p>

<pre><code><b>- render, by progressive refinement</b>, as many frames as wanted
  - display UI feedback
  <b>- render a frame, to the image</b>
    <b>- sample each image pixel</b>
      <b>- make sample ray direction</b> (with sub-pixel jitter)
      <b>- get radiance returning in sample direction</b>

        <b>- intersect ray with scene</b>
          - if octree branch
            - step through subcells and recurse
              - find which subcell holds ray origin
              - step through intersected subcells
                - intersect nested subcell (by recursing)
                - exit branch if triangle hit
                - find next subcell ray moves to
                - move to (outer face of) next subcell, or exit branch
          - else octree leaf
            - exhaustively intersect contained triangles
              - avoid false intersection with triangle just come from
                - intersect ray with triangle
                  - check if nearest so far
                    - check intersection is inside cell bound
                      - note hit details

        <b>- if intersection hit</b>
          <b>- get local emission (only for first-hit)</b>
            - read triangle attribute

          <b>- calculate emitter sample</b>:
            emissive area, ideal diffuse BRDF:
              reflected = (emitivity * solidangle) * (emitterscount) *
                (cos(emitdirection) / pi * reflectivity)
            - request emitter sample point from scene
            - if emitter sample point available
              - if shadow ray is unshadowed
                - calculate inward emission value
                  - emit from front face of triangle only
                    - estimate solid angle
                    - multiply emitivity by solid angle
                - calculate amount reflected by triangle
                  - check both directions are on same side of triangle
                    (no transmission)
                    - calculate ideal diffuse BRDF:
                      radiance scaled by reflectivity, cos, and 1/pi
                - scale radiance by number of emitters in scene

          <b>- calculate recursive reflection</b>:
            single hemisphere sample, ideal diffuse BRDF:
              reflected = (inradiance * pi) * (cos(in) / pi * color) *
                reflectance
            reflectance magnitude is 'scaled' by the russian roulette,
            cos is importance sampled, and the pi and 1/pi cancel out,
            leaving just: inradiance * reflectance color
            - calculate next direction
              - do russian-roulette with reflectivity 'magnitude'
              - if alive
                - make direction as cosine-weighted importance sample
                  of hemisphere
                - make color by dividing-out mean from reflectivity
            - if not path end
              - recurse to 'get radiance returning in sample direction'
              - scale recursed radiance by color

          <b>- sum local emission, emitter sample, and recursive reflection</b>

        <b>- else no hit</b>
          <b>- use default/background scene emission</b>

      <b>- add radiance to image</b>
  <b>- save image</b> periodically
    <b>- divide pixel values by frame count</b>
    <b>- apply</b> (Ward linear) <b>tonemapping factor</b>
    - write image file (PPM P6 format)</code></pre>
   </section>


   <section id="downloads">
      <h3>Downloads</h3>

      <h4 id="downloads.version16">version 1.6</h4>
      <p id="downloads.version16-p0"><small>(updated 2013-05-04)</small></p>

      <table class="panel">
         <tr>
            <td>
               üì¶
               <a href="minilight16src.tar.gz">minilight16src.tar.gz</a>
            </td>
            <td class="tableitem"><b>All source code</b> in one package (167 KiB)</td>
         </tr>
         <tr>
            <td>
               üì¶
               <a href="minilight16exe.zip">minilight16exe.zip</a>
            </td>
            <td class="tableitem"><b>Executables</b> (from C) (Mac, Linux, Windows) (146 KiB)</td>
         </tr>
         <tr>
            <td>
               üìÑ
               <a href="minilight16-sha256sums.txt">minilight16-sha256sums.txt</a>
            </td>
            <td class="tableitem"><b>Sha-256 sums</b> (1 KiB)</td>
         </tr>
      </table>

      <p id="downloads.version16-p1">Individually:</p>

      <table class="panel">
         <tr>
            <td>
               üåä
               <a href="minilight16c.tar.gz">minilight16c.tar.gz</a>
            </td>
            <td class="tableitem"><b>C ISO-90</b> source code (36 KiB)</td>
         </tr>
         <tr>
            <td>
               üê´
               <a href="minilight16ocaml.tar.gz">minilight16ocaml.tar.gz</a>
            </td>
            <td class="tableitem"><b>OCaml 4.00</b> source code (31 KiB)</td>
         </tr>
         <tr>
            <td>
               üçê
               <a href="minilight16scheme.tar.gz">minilight16scheme.tar.gz</a>
            </td>
            <td class="tableitem"><b>Scheme R5RS</b> source code (36 KiB)</td>
         </tr>
         <tr>
            <td>
               üåô
               <a href="minilight16lua.tar.gz">minilight16lua.tar.gz</a>
            </td>
            <td class="tableitem"><b>Lua 5.1 / 5.2</b> source code (23 KiB)</td>
         </tr>
         <tr>
            <td>
               üåä
               <a href="minilight16cpp.tar.gz">minilight16cpp.tar.gz</a>
            </td>
            <td class="tableitem"><b>C++ ISO-98</b> source code (35 KiB)</td>
         </tr>
         <tr>
            <td>
               üêö
               <a href="minilight16scala.tar.gz">minilight16scala.tar.gz</a>
            </td>
            <td class="tableitem"><b>Scala 2.9</b> source code (30 KiB)</td>
         </tr>
         <tr>
            <td>
               üêâ
               <a href="minilight16python.tar.gz">minilight16python.tar.gz</a>
            </td>
            <td class="tableitem"><b>Python 2.5 / 2.6</b> source code (16 KiB) <br/>(Translation by Juraj Sukop)</td>
         </tr>
         <tr>
            <td>
               üíé
               <a href="minilight16ruby.tar.gz">minilight16ruby.tar.gz</a>
            </td>
            <td class="tableitem"><b>Ruby 1.8</b> source code (22 KiB)</td>
         </tr>
         <!--<tr>
            <td>
               üìÉ
               <a href="minilight152flex.tar.gz">minilight152flex.tar.gz</a>
            </td>
            <td class="tableitem"><b>Flex 2</b> source code (1.5.2) (36 KiB)</td>
         </tr>-->
      </table>

      <h4 id="downloads.version17">version 1.7</h4>
      <p id="downloads.version17-p0"><small>(updated 2013-05-04 &ndash; now supporting process-level parallelism and distribution)</small></p>

      <table class="panel">
         <tr>
            <td>
               üì¶
               <a href="minilight17c.tar.gz">minilight17c.tar.gz</a>
            </td>
            <td class="tableitem"><b>C ISO-90</b> source code (48 KiB)</td>
         </tr>
      </table>

      <h4 id="downloads.external">external</h4>

      <table class="panel">
         <tr>
            <td>
               ‚òï
               <a href="http://github.com/ORBAT/MiniLightJava">MiniLight <b>Java</b></a>
            </td>
            <td class="tableitem">translated by Tom Ekl&ouml;f</td>
         </tr>
         <tr>
            <td>
               #
               <a href="http://www.lomont.org/Software/#GraphicsDemos">MiniLight <b>C# 3.5</b></a>
            </td>
            <td class="tableitem">translated (with small extras) by Chris Lomont</td>
         </tr>
         <tr>
            <td>
               #
               <a href="http://www.voyce.com/index.php/2010/06/30/minilight-renderer-in-fsharp/">MiniLight <b>F#</b></a>
            </td>
            <td class="tableitem">translated by Ian Voyce</td>
         </tr>
         <tr>
            <td>
               ‚òÆ
               <a href="http://mark.reid.name/sap/">MiniLight <b>Clojure 2009</b></a>
            </td>
            <td class="tableitem">partial, by Mark Reid</td>
         </tr>
         <tr>
            <td>
               üê´
               <a href="http://github.com/mfp/ocaml-minilight/">MiniLight <b>OCaml</b></a>
            </td>
            <td class="tableitem">adjustments by <a href="http://eigenclass.org/">Mauricio Fern&aacute;ndez</a></td>
         </tr>
         <tr>
            <td>
               üìÉ
               <a href="https://github.com/darius/minilight.js">MiniLight <b>JavaScript 3</b></a>
            </td>
            <td class="tableitem">in progress, by Darius Bacon</td>
         </tr>
      </table>

      <h4 id="downloads.related">related</h4>

      <table class="panel">
         <tr>
            <td>
               üêç
               <a href="https://github.com/brunonery/scripts/blob/master/minilight_export.py"><b>Blender</b> exporter</a>
            </td>
            <td class="tableitem">by <a href="http://brunonery.com/">Bruno Nery</a></td>
         </tr>
      </table>
   </section>


   <section id="contribution">
      <h3>Contribution</h3>

      <p id="contribution-p0">If <i>you</i> can't resist doing a translation, I can probably add/link to it. It is a good way to learn 80% of a new language.</p>

      <p id="contribution-p1">Anyone else is, of course, free to diverge from the original guidelines, but they might be worth considering:</p>
      <ol>
         <li>Make it compact and simple (these are the priority), by good use of the language.</li>
         <li>Only optimize where <i>really</i> needed, and not excessively (you want to find out how well the compiler/language can do for itself with no manual help).</li>
         <li>Perhaps follow the main module separation design.</li>
         <li>Write the best code possible!</li>
      </ol>

      <p id="contribution-p2">Maybe sacrifice some clarity for compactness in the <code>SpatialIndex</code> module &ndash; it is a bit large <i>(it deserves careful testing, too)</i>. And, only to make the sizes comparable:</p>
      <ul>
         <li>lines should be &lt;= 80 chars</li>
         <li>indent ought to be 3-ish chars <i>(but mixing tabs and spaces is a heinous sin!)</i></li>
      </ul>

      <p id="contribution-p3">The main reference versions are <b>Scheme</b>, <b>OCaml</b> and <b>C</b>.</p>

      <p id="contribution-p4"><span class="e">hxa7241+www <i>(&alpha;&tau;)</i> googlem&zwnj;ail <i>(d&omicron;&tau;)</i> com</span></p>
   </section>

</section>

      </article>
   </main>

</body>

</html>
