<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head profile="http://dublincore.org/documents/dcq-html/">
   <title>Future software engineering's three bases - (note-20100317T2104Z) - HXA7241</title>

   <link rel="schema.DC"       href="http://purl.org/dc/elements/1.1/" />
   <meta name="DC.title"       content="Future software engineering's three bases - (note-20100317T2104Z) - HXA7241" />
   <meta name="DC.subject"     content="software engineering" />
   <meta name="DC.description" content="The future of software engineering is in combining less deliberate design with more automated generation and evolution." />
   <meta name="DC.type"        content="note" />
   <meta name="DC.type"        content="Text" />
   <link rel="DC.relation"     href="http://www.hxa.name/" />
   <meta name="DC.creator"     content="Harrison Ainsworth / HXA7241" />
   <meta name="DC.publisher"   content="Harrison Ainsworth / HXA7241" />
   <meta name="DC.rights"      content="Creative Commons BY-SA 3.0 License." />
   <meta name="DC.date"        content="2010-03-17" />
   <meta name="DC.format"      content="text/html" />
   <meta name="DC.format"      content="css1" />
   <meta name="DC.language"    content="en" />
   <link rel="DC.identifier"   href="http://www.hxa.name/notes/note-hxa7241-20100317T2104Z.html" />

   <meta name="keywords"       content="software engineering" />
   <meta name="description"    content="The future of software engineering is in combining less deliberate design with more automated generation and evolution." />
   <meta name="document"       content="hxa7241note1" />
   <meta name="license"        content="Creative Commons by-sa 3.0" />

   <link rel="stylesheet" type="text/css" href="hxa7241-note.css" />
   <link rel="shortcut icon" type="image/x-icon" href="../style/hxa7241.ico" />

   <script id="hxa7241-js" type="application/x-javascript" src="../style/hxa7241.js"></script>
</head>


<body>
<div class="paper">

<div class="edge" id="header"><a href="http://www.hxa.name/notes/">HXA notes</a></div>


<div id="heading">
   <h1>Future software engineering's three bases</h1>
   <h3><a href="http://www.hxa.name/notes/note-hxa7241-20100317T2104Z.html" title="permalink">NOTE-HXA7241-20100317T2104Z</a></h3>
   <h4>Harrison Ainsworth</h4>
</div>


<div id="text">

<div class="section" id="whole">
   <h5>The future of software engineering is in combining less deliberate design with more automated generation and evolution</h5>

   <p>There are three basic ways to make software:</p>

   <ul>
      <li><i>Design</i> it &ndash; exactly and completely out of previously designed building blocks.</li>
      <li><i>Generate</i> it &ndash; with algorithmic techniques filling in the gaps of rough, incomplete specifications.</li>
      <li><i>Evolve</i> it &ndash; let it autonomously adapt to, and be randomly shaped by, its usage environment.</li>
   </ul>

   <h4>The Current: Design</h4>

   <p>So far, software engineering has done the first, and raised efficiency by increasing and improving reuse and sharing. But there is a hard limit set by the &lsquo;no silver bullet&rsquo; law: essential complexity is dominant and unavoidable. Design complexity ultimately equates to resultant functionality &ndash; so you cannot substantially reduce design effort without losing functionality.</p>

   <h4>The Future: Automation</h4>

   <p>The way forward is with the latter two, because they avoid the essential complexity problem by automating the effort. This can yield greater gains than any improvement to design techniques. The trade-off is loss of control, but that is OK because only moderate control is really needed &ndash; we currently <i>over</i>control development.</p>

   <h4>Generation</h4>

   <p>There are many and various potentials for generation, all founded on reasonable means. Ideally, we would like to say, e.g., &ldquo;Make me an e-book reader program!&rdquo; and have some <abbr title="Artificial Intelligence">AI</abbr> figure out all the details. But the concept covers a large range, and the simple end is very feasible. With a compiler, we <i>do</i> say &ldquo;Make me a <code>foldl</code>!&rdquo;, and the instructions are generated by optimisation rules. This is not reuse of pre-made designs, but new specific, automated, effort. It is not as effective as manual design, but sufficiently close.</p>

   <p>Generation can be understood as automated design, following and adapting the same process and the same consituents:</p>

   <ul>
      <li>Infer what is wanted, and mine what component functionalities are available.</li>
      <li>Hold these in various rational structures, to be analysable and sythesisable.</li>
      <li>Follow a recursive and iterative process to assemble a design from parts.</li>
      <li>Optimise for maximising requirements fulfilment, and minimising design effort.</li>
   </ul>

   <p>These reduce to the familiar. No single magical breakthrough is required, just steady development of known methods focused on appropriate areas.</p>

   <h4>Evolution</h4>

   <p>We know evolution can produce immensely functional software because the evidence of DNA is all around. But it is also hard to understand and control &ndash; partly necessarily, so it must be circumscribed in use. Conveniently, the way evolution works and what it does fits with the way design works &ndash; they are complementary.</p>

   <p>Alongside engineering design's essential basis of theoretical knowledge is use of specific as-needed experimentation. Here is where evolution can be included. What experiment does by deliberate human steering, evolution can automate with random variation and statistical selection: both sharing the same iterative process. The less knowledge design has, and hence also the less control is useful, the more evolution is effective &ndash; and in a very robust and complete way.</p>

   <p>Further, there are clearly hierarchies of spatial and temporal structure in living forms. Though we do not currently understand how natural evolution works with abstraction, it does appear to be doing so. As more is discovered of DNA's logical structure and systems, it should eventually be possible to use and incorporate them in making artificial software.</p>

   <h4>Combining all three</h4>

   <p>Any of the three alone is sub-optimal or inadequate; we want the best combination:</p>

   <ul>
      <li><i>Design</i> only what is needed &ndash; only what needs to be, and can be, exact.</li>
      <li><i>Evolve</i> for the unknown &ndash; the pieces and aspects that are indeterminate.</li>
      <li><i>Generate</i> as much as possible &ndash; providing something between the previous two &ndash; and this is the leading element, setting the balance of all.</li>
   </ul>

   <p>So for the longer term of software engineering, perhaps it is worth investigating generation and evolution, and their integration with deliberate design.</p>

   <h5>Background</h5>
   <ul id="references">
      <li>&lsquo;No Silver Bullet&rsquo;; Brooks; 1986.</li>
      <li><a href="http://www.hxa.name/articles/content/software-engineering-design_hxa7241_2010.html">&lsquo;Understanding Software Engineering Design&rsquo;; Harrison Ainsworth; 2010.</a></li>
   </ul>
</div>

</div><!--text-->


<div class="edge" id="footer"><a href="http://www.hxa.name/notes/">http://www.hxa.name/notes/</a></div>

</div><!--paper-->

<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-596081-1";
urchinTracker();
</script>

</body>

</html>
