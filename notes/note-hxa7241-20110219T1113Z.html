<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-GB" lang="en-GB">

<head profile="http://dublincore.org/documents/dcq-html/">
   <title>Wittgenstein for programmers (part 1) - (note-20110219T1113Z) - HXA7241</title>

   <link rel="schema.DC"       href="http://purl.org/dc/elements/1.1/" />
   <meta name="DC.title"       content="Wittgenstein for programmers (part 1) - (note-20110219T1113Z) - HXA7241" />
   <meta name="DC.subject"     content="software-engineering, philosophy, philosophy of software engineering, Wittgenstein, tractatus, tractatus logico-philosophicus" />
   <meta name="DC.description" content="What does an early 20th century philosopher have to say about software engineering?" />
   <meta name="DC.type"        content="note" />
   <meta name="DC.type"        content="Text" />
   <link rel="DC.relation"     href="http://www.hxa.name/" />
   <meta name="DC.creator"     content="Harrison Ainsworth / HXA7241" />
   <meta name="DC.rights"      content="Creative Commons BY-SA 3.0 License." />
   <meta name="DC.date"        content="2011-02-19" />
   <meta name="DC.format"      content="text/html" />
   <meta name="DC.format"      content="css1" />
   <meta name="DC.language"    content="en-GB" />
   <link rel="DC.identifier"   href="http://www.hxa.name/notes/note-hxa7241-20110219T1113Z.html" />

   <meta name="keywords"       content="software-engineering, philosophy, philosophy of software engineering, Wittgenstein, tractatus, tractatus logico-philosophicus" />
   <meta name="description"    content="What does an early 20th century philosopher have to say about software engineering?" />
   <meta name="document"       content="hxa7241note1" />
   <meta name="license"        content="Creative Commons by-sa 3.0" />

   <link rel="stylesheet" type="text/css" href="hxa7241-note.css" />
   <link rel="shortcut icon" type="image/x-icon" href="../style/hxa7241.ico" />

   <script id="hxa7241-js" type="application/x-javascript" src="../style/hxa7241.js"></script>
</head>


<body>
<div class="paper">

<div class="edge" id="header"><a href="http://www.hxa.name/notes/">HXA notes</a></div>


<div id="heading">
   <h1>Wittgenstein for programmers (part 1)</h1>
   <h3><a href="http://www.hxa.name/notes/note-hxa7241-20110219T1113Z.html" title="permalink">NOTE HXA7241 2011-02-19T11:13Z</a></h3>
</div>


<div id="text">

<div class="section" id="whole">

   <h5>What does an early 20th century philosopher have to say about software engineering?</h5>


   <p>The roots of software are in the early 20th century: this was when Lambda Calculus and Combinatory Logic were invented. But it was also the time of significant philosophical work in and around logic. Perhaps the most prominent was Wittgenstein's Tractatus Logico-Philosophicus.</p>

   <p>And there is something particularly interesting for us: the Tractatus can be translated almost directly into the software domain.</p>

   <p>In this light, Wittgenstein is talking about language and our relationship to the world in a mechanical, or rather, &lsquo;digital&rsquo; way: as if it were like software. It is like a pre-echo of the software world in a time when no such now-familiar concepts yet existed to describe it. (Maybe it is notable that Wittgenstein studied engineering at university . . .)</p>


   <h3>The &lsquo;propositional model&rsquo; of software</h3>

   <p>Central in the Tractatus is the concept of the &lsquo;proposition&rsquo;: a statement about the world that can be true or false. It is a logical artifact used to describe the world (and so links logic and world together). This maps straightforwardly to software: a proposition becomes a program. Where a proposition <i>describes</i> the <i>world</i>, a program <i>constructs</i> the <i>imagination</i>, or intended-world &ndash; an artifact. A program is like an executable proposition.</p>

   <p>In terms of the so-called picture-theory: a propositional &lsquo;picture&rsquo; <i>depicts</i>, by its logical structure, a <i>state of affairs</i> &ndash; and software <i>computes</i>, by its digital structure, a set of <i>effects</i>.</p>

   <p>The propositional-model also says that:</p>
   <ul>
      <li>programs are built up from primitives,</li>
      <li>programs have an articulate structure that is the basis of their sense or meaning,</li>
      <li>a program's sense can be understood independently from knowing if it does what is wanted or not,</li>
      <li>the most elementary programs simply set a group of bits to be be output and DAC-ed as a primitive effect,</li>
      <li>the ultimate primitves &ndash; the outputs &ndash; have no logical structure, just effect.</li>
   </ul>

   <p>Translated <i>back</i> into the domain of propositions and human language, these are an interesting, controversial thesis. But for software, they seem readily acceptable if not self-evident. The model does seem to fit rather well &ndash; better than its original purpose.</p>

   <p>This &lsquo;propositional model&rsquo; captures a fundamental encompassing abstraction of what software is and does.</p>


   <h3>Implications of the model</h3>

   <p>A set of interrelated notions emerge from the propositional model:</p>

   <p>Software is a logical construction &ndash; it realises intent, in a logical structure. <i>Software is not really a &lsquo;language&rsquo; but a machine</i> (more fully, a stack of progressively narrower abstractions of machines).</p>

   <p>Software is determinate, limited &ndash; what can be constructed at all can be constructed precisely. It is contradictory to try to design software to meet truly unknown future needs. <i>You can only design for what you know</i>.</p>

   <p>Software is made of two orthogonal relations &ndash; its logical structure is wholly &lsquo;internal&rsquo;, but its correctness is &lsquo;externally&rsquo; fixed. There is a kind of error that <i>is</i> soluble, and there is a kind of error that is <i>not</i> soluble.</p>

   <p>Software is produced by design &ndash; design produces something new and dependent on human judgement. We can build things, but we can never say determinately, completely, finally, what we want: <i>development is essentially iterative</i>.</p>

   <p>Software does just what we ask it to &ndash; with an unparalleled fidelity and fluidity. The best we can aim for is just to do exactly what we want to do. Software engineering does not tell us <i>what</i> to do, it just helps us be clear about what we <i>are</i> doing. <i>Software engineering is about clarity</i>.</p>

   <p>These are all things we might already half-know, but the propositional model gives them a coherent foundation.</p>


   <h3>See the whole project</h3>

   <p>It was said the Tractatus could be translated into the software domain. Well, the above was merely an introduction. Now be intrigued and provoked by the whole presentation:</p>

   <ul>
      <li><a href="http://www.hxa.name/articles/content/tractatus-computo-philosophicus_hxa7241_2010.html"><b>&lsquo;Tractatus Computo-Philosophicus&rsquo; &ndash;</b> a brief re-imagining for software.</a></li>
      <li><a href="http://www.hxa.name/articles/content/tractatus-digito-philosophicus_hxa7241_2010.html"><b>&lsquo;Tractatus Digito-Philosophicus&rsquo;</b> &ndash; a (partial) &lsquo;translation&rsquo; to software.</a></li>
   </ul>
</div>

</div><!--text-->


<div class="edge" id="footer"><a href="http://www.hxa.name/notes/">http://www.hxa.name/notes/</a></div>

</div><!--paper-->

<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-596081-1";
urchinTracker();
</script>

</body>

</html>
