<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-GB" lang="en-GB">

<head profile="http://dublincore.org/documents/dcq-html/">
   <title>Stone cathedrals, structure-preserving-transformations, and software development - (note-20110327T1046Z) - HXA7241</title>

   <link rel="schema.DC"       href="http://purl.org/dc/elements/1.1/" />
   <meta name="DC.title"       content="Stone cathedrals, structure-preserving-transformations, and software development - (note-20110327T1046Z) - HXA7241" />
   <meta name="DC.subject"     content="software-engineering, structure-preserving-transformation, construction" />
   <meta name="DC.description" content="This note stems from two sources: 'How To Build A Cathedral' (BBC; 2008) http://www.bbc.co.uk/programmes/b00b09rb -- a TV documentary; and 'structure-preserving-transformation' -- a phrase from Christopher Alexander. And it leads to a seeming weakness in sofware development -- how we systematise 'construction'." />
   <meta name="DC.type"        content="note" />
   <meta name="DC.type"        content="Text" />
   <link rel="DC.relation"     href="http://www.hxa.name/" />
   <meta name="DC.creator"     content="Harrison Ainsworth / HXA7241" />
   <meta name="DC.rights"      content="Creative Commons BY-SA 3.0 License." />
   <meta name="DC.date"        content="2011-03-27" />
   <meta name="DC.format"      content="text/html" />
   <meta name="DC.format"      content="css1" />
   <meta name="DC.language"    content="en-GB" />
   <link rel="DC.identifier"   href="http://www.hxa.name/notes/note-hxa7241-20110327T1046Z.html" />

   <meta name="keywords"       content="software-engineering, structure-preserving-transformation, construction" />
   <meta name="description"    content="This note stems from two sources: 'How To Build A Cathedral' (BBC; 2008) http://www.bbc.co.uk/programmes/b00b09rb -- a TV documentary; and 'structure-preserving-transformation' -- a phrase from Christopher Alexander. And it leads to a seeming weakness in sofware development -- how we systematise 'construction'." />
   <meta name="document"       content="hxa7241note1" />
   <meta name="license"        content="Creative Commons by-sa 3.0" />

   <link rel="stylesheet" type="text/css" href="hxa7241-note.css" />
   <link rel="shortcut icon" type="image/x-icon" href="../style/hxa7241.ico" />

   <script id="hxa7241-js" type="application/x-javascript" src="../style/hxa7241.js"></script>
</head>


<body>
<div class="paper">

<div class="edge" id="header"><a href="http://www.hxa.name/notes/">HXA notes</a></div>


<div id="heading">
   <h1>Stone cathedrals, structure-preserving-transformations, and software development</h1>
   <h3><a href="http://www.hxa.name/notes/note-hxa7241-20110327T1046Z.html" title="permalink">NOTE HXA7241 2011-03-27T10:46Z</a></h3>
</div>


<div id="text">

<div class="section" id="whole">

   <h5>This note stems from two sources: <a href="http://www.bbc.co.uk/programmes/b00b09rb">&lsquo;How To Build A Cathedral&rsquo; (BBC; 2008)</a> &ndash; a TV documentary; and &lsquo;structure-preserving-transformation&rsquo; &ndash; a phrase from Christopher Alexander. And it leads to a seeming weakness in sofware development &ndash; how we systematise &lsquo;construction&rsquo;.</h5>


   <p>Medieval cathedrals ought not to be thought of as merely primitive. Instead they are simple engineering systems, carried through to full elaboration. In this they are exemplars for all architecture and engineering.</p>

   <p>Alexander's overall ideas or thesis seems aesthetical rather than logical, but that one phrase is amply suggestive. Think of it in the developmental biology way: forms take shape by successive alteration and refinement of previous ones.</p>

      <p>&bull; &bull; &bull;</p>

   <p>What is falsework (a temporary supporting framework) during construction? &ndash; as in medieval cathedral building, using wood structures to then build stone structures. What is it in the sense of: how does it fit into the engineering design process?</p>

   <p>It is not recursive (de/)composition, nor iterative development. It is almost like iteration &ndash; but it is entirely deliberate, determinate, known how it will go, what it is for.</p>

   <p>The answer is, it is to make, or fake, a structure-preserving-transformation. A direct transform cannot be done, so a step is inserted.</p>

      <p>&bull; &bull; &bull;</p>

   <p>With a gothic arch, the structure maintained by construction is ostensibly physical. An arch has integrity only when complete. You cannot build it just by successively putting its parts together &ndash; it collapses. The method of construction makes a wooden framework to support the pieces until complete, then it can be removed.</p>

   <p><i>All construction is structure-preserving-transformation</i>. There is the design of the intended product, but it is realised through a system of construction. Construction maintains some kind of structure from start to finish, even if it is just the abstract intent of the design.</p>

   <p><i>Construction, in general, is a sequence of steps: each with the purpose of enabling the next to be taken, and the whole ending in the product.</i></p>

      <p>&bull; &bull; &bull;</p>

   <p>(Logic is structure-preserving-transformation in the most abstract sense.)</p>

      <p>&bull; &bull; &bull;</p>

   <p>So what do we do with software?</p>

   <p>Test-driven development is not like construction: it <i>indicates</i> when parts or whole is complete, but that is not the same as <i>leading</i> to the end point; and it does not enable and hence set a sequence of steps to follow.</p>

   <p>Stubbing-out functions, and generated code frameworks are like construction: they create intermediate forms. But these are limited, rudimentary, and/or not consistently usual practice.</p>

   <p>Programming incrementally and visibly with small pieces, as is the style of Lisp and and maybe Smalltalk, also resembles construction. But it is &lsquo;culture&rsquo; not implementation.</p>

      <p>&bull; &bull; &bull;</p>

   <p>Software is, in a basic sense, in its most basic manual demands, just a string of bits. There is no need for construction like other mediums, because any bit and any part can be changed in any way at any time. This is a great merit of the medium, but it brings a disadvantage.</p>

   <p>Normally, construction does another thing too. It imposes an organisation on our activity, on our control and verification of our intentions. We may not know that we need or benefit from this, but physical construction gave it anyway as a side-effect.</p>

   <p>But with software we have lost this support. And software, in its higher senses, is <i>not</i> just a structureless string of bits. It is for reflecting objective algorithms and our intentions, both of which <i>are</i> highly structured.</p>

      <p>&bull; &bull; &bull;</p>

   <p>Physical building-blocks constrain both the final form <i>and</i> the steps to reach it. But in software, the building-blocks only constrain the final form.</p>

   <p>You can only make certain things with functions for <code>+ - * /</code> (or more precisely, you can only make them in certain ways), but we build by editing chars in text files. It is like designing a house of bricks but building it by moving atoms.</p>

   <p>Why is constraint valuable? Because a set of building-blocks constitutes a logical framework, and that enables understanding &ndash; it <i>is</i> understanding. We can understand finished algorithms, but in construction we are disordered and in darkness; we have no logical framework and hence no understanding.</p>

      <p>&bull; &bull; &bull;</p>

   <p>What we have is the popular vague notion of &lsquo;iterative and incremental&rsquo;, what we do not have is a clear, defined, detailed set of &lsquo;mechanisms&rsquo; at the real programming level. We could do better here. (This is related to but distinct from refactoring. That changes representation while maintaining function. This is about partly changing function while partly maintaining it.) Software development would benefit from a controlled way of moving from state to state: an appropriate set of structure-preserving-transformations.</p>


   <p>Background:</p>
   <ul>
      <li><a href="http://www.hxa.name/articles/content/software-engineering-design_hxa7241_2010.html">&lsquo;Understanding Software Engineering Design&rsquo;</a></li>
   </ul>
</div>

</div><!--text-->


<div class="edge" id="footer"><a href="http://www.hxa.name/notes/">http://www.hxa.name/notes/</a></div>

</div><!--paper-->

<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-596081-1";
urchinTracker();
</script>

</body>

</html>
