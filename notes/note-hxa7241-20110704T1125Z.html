<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-GB" lang="en-GB">

<head profile="http://dublincore.org/documents/dcq-html/">
   <title>Distinguishing abstraction and change - (note-20110704T1125Z) - HXA7241</title>

   <link rel="schema.DC"       href="http://purl.org/dc/elements/1.1/" />
   <meta name="DC.title"       content="Distinguishing abstraction and change - (note-20110704T1125Z) - HXA7241" />
   <meta name="DC.subject"     content="software engineering, abstraction, change" />
   <meta name="DC.description" content="Abstraction and change overlap in some way, and maybe it is worth thinking a little about what that means and how they are separate." />
   <meta name="DC.type"        content="note" />
   <meta name="DC.type"        content="Text" />
   <link rel="DC.relation"     href="http://www.hxa.name/" />
   <meta name="DC.creator"     content="Harrison Ainsworth / HXA7241" />
   <meta name="DC.rights"      content="Creative Commons BY-SA 3.0 License." />
   <meta name="DC.date"        content="2011-07-04" />
   <meta name="DC.format"      content="text/html" />
   <meta name="DC.format"      content="css1" />
   <meta name="DC.language"    content="en-GB" />
   <link rel="DC.identifier"   href="http://www.hxa.name/notes/note-hxa7241-20110704T1125Z.html" />

   <meta name="keywords"       content="software engineering, abstraction, change" />
   <meta name="description"    content="Abstraction and change overlap in some way, and maybe it is worth thinking a little about what that means and how they are separate." />
   <meta name="document"       content="hxa7241note1" />
   <meta name="license"        content="Creative Commons by-sa 3.0" />

   <link rel="stylesheet" type="text/css" href="hxa7241-note.css" />
   <link rel="shortcut icon" type="image/x-icon" href="../style/hxa7241.ico" />

   <script id="hxa7241-js" type="application/x-javascript" src="../style/hxa7241.js"></script>
</head>


<body>
<div class="paper">

<div class="edge" id="header"><a href="http://www.hxa.name/notes/">HXA notes</a></div>


<div id="heading">
   <h1>Distinguishing abstraction and change</h1>
   <h3><a href="http://www.hxa.name/notes/note-hxa7241-20110704T1125Z.html" title="permalink">NOTE HXA7241 2011-07-04T11:25Z</a></h3>
</div>


<div id="text">

<div class="section" id="whole">
   <h5>Abstraction and change overlap in some way, and maybe it is worth thinking a little about what that means and how they are separate.</h5>


   <h3>Extensibility</h3>

   <p>The idea of &lsquo;designing for extensibility/change&rsquo; merges the two things. And it cannot be correct or possible in general.</p>

   <p>An example is describing the &lsquo;open-closed principle&rsquo; (<a href="http://docs.eiffel.com/book/method/object-oriented-software-construction-2nd-edition">&lsquo;Object-Oriented Software Construction&rsquo;; Meyer; 1997.</a> s3.1 p40) as: &ldquo;In other words, (in an ideal world...) you should never need to change existing code or classes: All new functionality can be added by adding new subclasses or methods, or by reusing existing code through delegation.&rdquo; (<a href="http://c2.com/cgi/wiki?OpenClosedPrinciple">http://c2.com/cgi/wiki?OpenClosedPrinciple</a>)</p>

   <p>This implies we should be aiming to avoid changing things, that software engineering is or should be &lsquo;striving for exstensibility&rsquo; &ndash; pre-planned extensibility. This cannot really work.</p>

   <ol>
      <li>If you have produced some code, or design, or anything really, you have <i>defined</i> something.</li>
      <li>If you have defined something, you have implicitly defined all those things that <i>are not</i> it.</li>
      <li>If some new thing you want is in that set of &lsquo;not it&rsquo; things, you <i>must change something</i>.</li>
   </ol>

   <p>The very act of designing something creates the possibility of its needing to be changed. If you design an abstraction, you have made some room for change &ndash; in the varying part of the abstraction. But you have also, necessarily, defined something as fixed that resists change.</p>


   <h3>Reuse</h3>

   <p>Reuse is really just use &ndash; it does not require some special kind of abstraction or design. It is just design for a set of users that are more spread out in space or time.</p>

   <p>The problem of designing for &lsquo;reuse&rsquo; is really the same problem as any design: if you cannot get good information on what is required, you cannot make a good design, one that will be <i>useful</i>. The problem of designing for &lsquo;reuse&rsquo; is we cannot get good info &ndash; partly because we cannot predict the future. The problem of designing for &lsquo;reuse&rsquo; is knowing <i>what</i> is likely to be wanted, not really of <i>how</i> to build it.</p>

   <p>The hard problem of reuse is of <i>what</i> not how. It is about knowing <i>what</i> will be needed. That cannot be solved with language/programming/technical means.</p>

      <p>* * *</p>

   <p class="lowlight">But you could say we can predict probabilistically: we can build a picture of what requirements have what probability of being needed. And therefore that we can benefit from particular technical means to represent that particular kind of probabilistic picture.</p>

   <p class="lowlight">That seems to contradict the thesis, but it is actually just saying the same thing. Do we have that probabilistic data, that probabilistic picture? If we do, we have the info of <i>what</i> is to be built. There is something solid that an abstraction can be designed for &ndash; that its fixed part can represent. So we are back where we were. A probabilistic picture is just another kind of knowledge.</p>


   <h3>Conclusion</h3>

   <p>Abstraction is a way of handling multiple things as one thing. Multiple &lsquo;tokens&rsquo; are represented/encompassed/grasped by one &lsquo;type&rsquo; &ndash; in philosophical terminology. (Ultimately, this is good because it lets us do multiple pieces of work (understanding, production, etc.) with a single piece of effort. Abstraction is like the basic force-multiplier of the information realm.)</p>

   <p>But the relation between &lsquo;tokens&rsquo; &ndash; instances of an abstraction &ndash; is not really that of change. (Just because instances occur at different times does not make the situation one of change.) If a change fits as a new instance, either you are just lucky &ndash; which is not a sensible, reliable way of working in general, or you planned it &ndash; in which case it is not really a change in a strong sense.</p>

   <p>We want to address hard change, change you do <i>not</i> expect. Designing abstractions by thinking ahead cannot do that. Change is handled by thinking about what you know <i>now</i>: the abstractions you have, those you need, and how to go from one to the other.</p>


   <h3>Related</h3>

   <ul>
      <li><a href="http://www.hxa.name/notes/note-hxa7241-20110410T0910Z.html">&lsquo;Definition of &lsquo;abstract&rsquo;&rsquo;; HXA note; 2011.</a></li>
      <li><a href=" http://www.hxa.name/notes/note-hxa7241-20100313T1725.html">&lsquo;Design should be backward-looking&rsquo;; HXA note; 2010.</a></li>
      <li><a href=" http://www.hxa.name/notes/note-hxa7241-20100201T2038.html">&lsquo;The illusion in up-front design&rsquo;; HXA note; 2010.</a></li>
      <li><a href=" http://www.hxa.name/notes/note-hxa7241-20110424T0826Z.html">&lsquo;Considering the limits of DRY(&lsquo;dont repeat yourself&rsquo;) / factoring&rsquo;; HXA; 2011.</a></li>
   </ul>
</div>

</div><!--text-->


<div class="edge" id="footer"><a href="http://www.hxa.name/notes/">http://www.hxa.name/notes/</a></div>

</div><!--paper-->

<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-596081-1";
urchinTracker();
</script>

</body>

</html>
