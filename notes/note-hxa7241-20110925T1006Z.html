<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-GB" lang="en-GB">

<head profile="http://dublincore.org/documents/dcq-html/">
   <title>Enduring software - (note-20110925T1006Z) - HXA7241</title>

   <link rel="schema.DC"       href="http://purl.org/dc/elements/1.1/" />
   <meta name="DC.title"       content="Enduring software - (note-20110925T1006Z) - HXA7241" />
   <meta name="DC.subject"     content="software-engineering, types, programming" />
   <meta name="DC.description" content="Making 'enduring software' looks more like a requirements/product-design problem than an engineering problem." />
   <meta name="DC.type"        content="note" />
   <meta name="DC.type"        content="Text" />
   <link rel="DC.relation"     href="http://www.hxa.name/" />
   <meta name="DC.creator"     content="Harrison Ainsworth / HXA7241" />
   <meta name="DC.rights"      content="Creative Commons BY-SA 3.0 License." />
   <meta name="DC.date"        content="2011-09-25" />
   <meta name="DC.format"      content="text/html" />
   <meta name="DC.format"      content="css1" />
   <meta name="DC.language"    content="en-GB" />
   <link rel="DC.identifier"   href="http://www.hxa.name/notes/note-hxa7241-20110925T1006Z.html" />

   <meta name="keywords"       content="software-engineering" />
   <meta name="description"    content="Making 'enduring software' looks more like a requirements/product-design problem than an engineering problem." />
   <meta name="document"       content="hxa7241note1" />
   <meta name="license"        content="Creative Commons by-sa 3.0" />

   <link rel="stylesheet" type="text/css" href="hxa7241-note.css" />
   <link rel="shortcut icon" type="image/x-icon" href="../style/hxa7241.ico" />

   <script id="hxa7241-js" type="application/x-javascript" src="../style/hxa7241.js"></script>
</head>


<body>
<div class="paper">

<div class="edge" id="header"><a href="http://www.hxa.name/notes/">HXA notes</a></div>


<div id="heading">
   <h1>Enduring software</h1>
   <h3><a href="http://www.hxa.name/notes/note-hxa7241-20110925T1006Z.html" title="permalink">NOTE HXA7241 2011-09-25T10:06Z</a></h3>
</div>


<div id="text">

<div class="section" id="whole">
   <h5>Making &lsquo;enduring software&rsquo; looks more like a requirements/product-design problem than an engineering problem.</h5>


   <p>Is it possible to say anything a priori about enduring software? Maybe there is a simple law that sets the bounds:</p>

   <blockquote>
      <p>&lsquo;Unlimited&rsquo; software must have either: a Turing-complete abstraction/interface, or a way to transform the abstraction. If it has neither, it is limited, and so will eventually fail to meet requirements given time and circumstance.</p>
   </blockquote>

   <p class="lowlight">(&lsquo;Turing-complete interface/abstraction&rsquo;? An interface &ndash; that is, an abstraction &ndash; is a way to control a machine (in a sense, it represents a machine). So the widest, most powerful abstraction, is one that controls/represents a machine that can do anything. We know what that is: Turing-complete.)</p>

   <p>This says nothing more than what is already known. But at least it makes it obvious that most claims or expectations of future-proof software must be false (they have neither Turing-complete interfaces, nor well-defined means of transform).</p>

   <p>But the second point is that this is quite hollow. If the (overall) abstraction is Turing-complete then the software does not really do anything &ndash; it is just another general machine on top of the one underneath &ndash; you end up where you started. And effectively the same with transformation (although maybe that is a little more interesting . . .).</p>

   <p>&mdash;&mdash;&mdash;</p>

   <p>The whole idea of enduring software is something of an illusion. It cannot quite mean what it appears to. But it is possible to clarify what it <i>does</i> mean.</p>

   <p>The idea of &lsquo;enduring&rsquo; is of something that can keep going despite its surroundings changing &ndash; enduring <i>against</i> something. That is meaningful with material machines: you want the concept to endure despite the instability of the material that embodies it. But software has no equivalent embodying material (it is its own); there is nothing the concept is trying to persist against.</p>

   <p>The idea of enduring software only makes sense as something that is <i>not</i> really about software exactly. If software is used for a long time, it is because the particular use it performs is still wanted: it is really the <i>use</i>, the <i>purpose</i>, that is enduring.</p>

   <p>Designing enduring software is about pragmatic, a posteriori, knowledge. That is, about discovering and inventing particular structures that happen to be good for the particular environments and uses we happen to have.</p>

   <p>&lsquo;Enduring software&rsquo; is not a technical matter, not about some special way of designing/implementing, but about the <i>requirements</i> side. It is about finding or envisioning the right software to make, rather than the right way to make it.</p>
</div>

</div><!--text-->


<div class="edge" id="footer"><a href="http://www.hxa.name/notes/">http://www.hxa.name/notes/</a></div>

</div><!--paper-->

<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-596081-1";
urchinTracker();
</script>

</body>

</html>
