<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-GB" lang="en-GB">

<head profile="http://dublincore.org/documents/dcq-html/">
   <title>Power, predictability, and regularity - (note-20111113T1241Z) - HXA7241</title>

   <link rel="schema.DC"       href="http://purl.org/dc/elements/1.1/" />
   <meta name="DC.title"       content="Power, predictability, and regularity - (note-20111113T1241Z) - HXA7241" />
   <meta name="DC.subject"     content="software-engineering, programming languages" />
   <meta name="DC.description" content="At the deepest level, software seems to have an essential trade-off of power against predictability. And the problem there is not a matter of conformance but of clarity. That means perhaps the best we can do is design programming languages to have a kind of 'regularity'." />
   <meta name="DC.type"        content="note" />
   <meta name="DC.type"        content="Text" />
   <link rel="DC.relation"     href="http://www.hxa.name/" />
   <meta name="DC.creator"     content="Harrison Ainsworth / HXA7241" />
   <meta name="DC.rights"      content="Creative Commons BY-SA 3.0 License." />
   <meta name="DC.date"        content="2011-11-13" />
   <meta name="DC.format"      content="text/html" />
   <meta name="DC.format"      content="css1" />
   <meta name="DC.language"    content="en-GB" />
   <link rel="DC.identifier"   href="http://www.hxa.name/notes/note-hxa7241-20111113T1241Z.html" />

   <meta name="keywords"       content="software-engineering, programming languages" />
   <meta name="description"    content="At the deepest level, software seems to have an essential trade-off of power against predictability. And the problem there is not a matter of conformance but of clarity. That means perhaps the best we can do is design programming languages to have a kind of 'regularity'." />
   <meta name="document"       content="hxa7241note1" />
   <meta name="license"        content="Creative Commons by-sa 3.0" />

   <link rel="stylesheet" type="text/css" href="hxa7241-note.css" />
   <link rel="shortcut icon" type="image/x-icon" href="../style/hxa7241.ico" />

   <script id="hxa7241-js" type="application/x-javascript" src="../style/hxa7241.js"></script>
</head>


<body>
<div class="paper">

<div class="edge" id="header"><a href="http://www.hxa.name/notes/">HXA notes</a></div>


<div id="heading">
   <h1>Power, predictability, and regularity</h1>
   <h3><a href="http://www.hxa.name/notes/note-hxa7241-20111113T1241Z.html" title="permalink">NOTE HXA7241 2011-11-13T12:41Z</a></h3>
</div>


<div id="text">

<div class="section" id="whole">
   <h5>At the deepest level, software seems to have an essential trade-off of power against predictability. And the problem there is not a matter of conformance but of clarity. That means perhaps the best we can do is design programming languages to have a kind of &lsquo;regularity&rsquo;.</h5>


   <p>John Shutt <a href="http://fexpr.blogspot.com/2011/11/allowing-and-disallowing.html">considers recently</a> whether there is, in software/programming-languages, an essential unavoidable trade-off between:</p>
   <ul>
      <li>allowing maximally versatile ways of doing things, with maximal facility,</li>
      <li>disallowing undesirable behavior.</li>
   </ul>

   <p>Let us look at this somewhat from the view of the <a href="http://www.hxa.name/notes/note-hxa7241-20110219T1113Z.html">Wittgensteinian &lsquo;propositional model&rsquo;</a> of software.</p>

   <p>&mdash;&mdash;&mdash;</p>

   <p>This depends on how one defines undesirable behaviour.</p>

   <p>If it means things like dereferencing null pointers, then there really seems no necessary/essential conflict or trade-off. It is just a technical detail, and you just build a language which avoids it. It puts no limits on computation in general. Any trade-off is an a posteriori problem: some languages and features might imply particular trade-offs, others different ones, and there seems always the possibility of finding/devising one better.</p>

   <p>But if undesirable behaviour means instead something more general, like anything unpredicted, or unwanted as judged by requirements, then there really does seem to be a deep, inescapable trade-off.</p>

   <p>Because what does the most basic principle of the theory of computation say, in effect? That a limited set of elements can produce an unlimited set of behaviours. That really seems to be saying some must be unpredictable &ndash; and you cannot pre-empt behaviours you cannot predict.</p>

   <p>But this choice of two intepretations does not really give a way out. (And not just because the boundary between them seems actually quite blurred.) Because the side of merely technical matters (null deref etc.) is perhaps not very important: it could be completely solved and maybe it would not do much good. The real problem is the general one.</p>

   <p>&mdash;&mdash;&mdash;</p>

   <p>The fundamental issue in programming, relevant here, is clarity.</p>

   <p>A programming language just gives you a limited set of elemental actions, which you assemble to make particular programs. Ideally, you want a language to simply show you clearly what you are building: you look at the software, and if some part does what you want you keep it, and if it does not you remove it. The only conformance is to your intention. There are ideally, at bottom, no &lsquo;undesirable&rsquo; or disallowed actions; there are just different features that do different things, and you choose them.</p>

   <p>There is, ultimately, no allowing and disallowing. The language just does exactly what you say, and shows you clearly what you did say.</p>

   <p>Type systems (or any automated checking) do not really check &lsquo;conformance&rsquo; (quite, exactly), they can only check <i>consistency</i>. They check if what you say in one place matches what you say somewhere else. They cannot check if what you say will create the effect you want.</p>

   <p>&mdash;&mdash;&mdash;</p>

   <p>&lsquo;Undesirable behaviour&rsquo;, then, is indirect consequences that were unforeseen. Here is where the real problem is, and where the idea of regularity comes in.</p>

   <p>No matter how clear the basic programming elements are, in a fully powerful language it is always possible to make structures that go further than can be (easily, arbitrarily) predicted. So it is impossible, in general, to make software completely clear.</p>

   <p>But what we can perhaps do is give programming and languages some &lsquo;regularity&rsquo;: keep the range and consequences of that unpredictability constrained within some bounds. To put it analogously to mechanics: to give language constructs some &lsquo;damping&rsquo;, to make them more &lsquo;stable&rsquo;. Each programming element interacts with others &ndash; hence toward unpredictable ramifications &ndash; and what we want is that those interactions sort-of reduce with distance. This is a kind of expanded notion of the principle of least surprise.</p>

   <p>This is a rather vague and somewhat metaphorical description. Figuring out what it means more exactly is the thing to do. But this still does not really solve the original problem. It is in effect suggesting we address the problem of the <i>power</i> of computation by making it <i>less</i> powerful. There <i>is</i>, at the most general level, an essential conflict/trade-off: the only thing we can do is find the optimal arrangement for our circumstances, and human abilities.</p>
</div>

</div><!--text-->


<div class="edge" id="footer"><a href="http://www.hxa.name/notes/">http://www.hxa.name/notes/</a></div>

</div><!--paper-->

<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-596081-1";
urchinTracker();
</script>

</body>

</html>
